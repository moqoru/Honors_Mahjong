# <자패 마작 게임 제작 보고서>

## 1. 소개

- 이 게임은 대학교 자바 프로그래밍 과목의 기말 프로젝트로 제작하였으며, 당시 제출했던 보고서의 내용을 토대로 마크다운 문서를 제작하였다.
- 2인 1조로 팀을 꾸려 일본, 중국 등 다양한 나라에서 성행하는 보드게임인 '마작' 에서 룰을 간소화하고 단순하게 만든 '자패마작' 이라는 게임을 제작하였다. 자패마작이란 CPU와 플레이어 2명이서 대결하여, 東西南北白發中 7종류의 패 4세트, 총 28개의 패를 이용하여 특정한 형태가 완성되도록 패를 먼저 구성하면 승리하는 게임이다. 게임상에서는 입력의 편의를 위해 각 종류의 패를 東="E", 南="S", 西="W", 北="N", 白="O", 發="G", 中="R"로 표기하였다.

## 2. 게임 플레이 규칙

### 2-1. 게임 전체 진행

- CPU와 플레이어는 첫 게임이 시작될 때 15점씩을 가지고 시작하며, 승리한 사람이 획득한 점수만큼 패배한 사람의 점수를 가져오고 어느 한쪽의 점수가 0점 이하가 되면 게임이 끝난다.

  - 각 게임이 시작되면 패를 무작위로 섞은 뒤 CPU와 플레이어는 7개의 패를 받으며, 첫 게임에서는 플레이어부터, 이후로는 이전 게임에서 승리한 쪽부터 시작해서 번갈아가며 1개의 패를 받은 뒤 필요 없는 패 1개를 상대방이 볼 수 있도록 자신의 앞쪽에 버리는 것을 반복한다.

  - 자신의 차례에서 받은 패로 특정한 형태가 완성되면 '쯔모'를 선언해서 승리할 수 있으며, 현재 상대방 차례에서 버린 패 1개를 자신이 들고 있는 패에 포함시켜서 특정한 형태를 완성시킬 수 있는 상태이면 '론'을 선언해서 승리할 수 있다. 단, 론을 선언할 때는 포함시키는 상대방의 패가 자신이 버렸던 패가 아니어야 한다.

  - 또한, 28개의 패를 모두 사용할 때까지 아무도 자신의 패로 형태를 완성시키지 못할 경우, 무승부가 되며 그 게임에서 나중에 시작한 사람이 다음 게임에서 먼저 시작한다.

### 2-2. 상대방의 패를 가져오는 규칙

- 때때로 상대방이 버린 패를 가져와서 자신의 패를 구성하는 데 쓸 수 있으며, 이때는 상대방에게 자신이 그 패로 형태를 만들 수 있다는 것을 보여주기 위해 패의 일부를 상대방이 볼 수 있게 공개하게 된다.

  - 같은 종류의 패 2개가 있을 때 상대방이 같은 종류의 패를 버렸을 경우 '퐁'을 선언하면 상대방의 패를 가져온 뒤 같은 종류의 패 3개를 공개하며 게임상에서는 "XX+X"로 표시한다. 퐁을 선언할 경우, 자신의 차례에 가져올 패 대신 상대방의 패를 가져왔으므로 바로 자신의 필요 없는 패 1개를 버린다.

  - 같은 종류의 패 3개가 있을 때 상대방이 같은 종류의 패를 버렸을 경우 '대명깡'을 선언하면 상대방의 패를 가져온 뒤 같은 종류의 패 4개를 공개하며 게임상에서는 "XXX+X"로 표시한다.

  - 또한 상대방이 버린 패를 가져오는 경우는 아니지만, 자신의 차례에서 패를 가져왔을 때 자신의 패 중에서 같은 종류의 패 4개가 있을 경우 '안깡'을 선언하면 같은 종류의 패 4개를 공개하며 게임상에서는 "XXXX"의 형식으로 표시한다.

  - 그리고 자신의 차례에서 자신의 패 중에 이미 퐁을 선언한 패와 같은 종류의 패가 있을 경우 '가깡'을 선언하면 같은 종류의 패 4개를 공개하며 게임상에서는 "XX+X+X"로 표시한다.

  - 모든 종류의 깡을 선언할 경우, 같은 종류의 패 4개를 3개의 패와 동일하게 취급하므로, 퐁과 달리 추가로 1개의 패를 받은 뒤 필요 없는 패 1개를 버린다.

### 2-3. 점수 계산

- 게임에서 승리할 수 있는 패의 형태는 다음과 같다. (설명의 편의를 위해 같은 종류 패 4개를 '깡쯔', 3개를 '커쯔', 2개를 '또이쯔'로 표기하였다.)

  1. 2종류의 패로 커쯔 또는 깡쯔를 만들고, 1종류의 패로 또이쯔를 만드는 경우

     - One closed triplet, 이안커(1점) : 퐁을 선언하지 않고 커쯔 1개를 만듦

     - Two closed triplets, 량안커(3점) : 퐁을 선언하지 않고 커쯔 2개를 만듦

     - One closed kan, 이안깡(2점) : 안깡을 선언하여 깡쯔 1개를 만듦

     - Two kans, 량깡쯔(3점) : 깡 종류에 관계없이 깡쯔 2개를 만듦

     - Two closed kans, 량안깡(5점) : 안깡을 선언하여 깡쯔 2개를 만듦

  2. 1번의 경우, 패를 특정한 종류의 패로 구성하면 점수가 추가된다.

     - Three dragons, 대삼원(4점) : 모든 패를 白發中(OGR)로만 구성

     - Two dragons, 소삼원(3점) : 2개의 커쯔 또는 깡쯔를 白發中(OGR) 중 1가지씩의 패로 구성

     - Three winds, 대사희(3점) : 모든 패를 東西南北(ESWN)으로만 구성

     - Two winds, 소사희(2점) : 2개의 커쯔 또는 깡쯔를 東西南北(ESWN) 중 1가지씩의 패로 구성

  3. 단, 형태는 만들었지만 위의 경우에 해당되지 않는 경우, 점수가 없어 승리하지 못한다.
     - 예시 : SS OOO+O EE+E = 東 퐁 + 白 대명깡 + 南 또이쯔. 점수가 0점이다.

  4. 4종류의 패로 또이쯔를 만드는 경우

     - Dragon pairs, 사희또이쯔(3점) : 모든 패를 東西南北으로만 구성

     - Wind pairs, 삼원또이쯔(3점) : 3개의 또이쯔를 白發中으로 구성

     - Four pairs, 스또이츠(1점) : 위 두 가지 형태에 해당되지 않는 경우

  5. 7종류의 패 중 1종류의 패로 또이쯔를 만들고, 6종류의 패는 1개씩인 패를 만드는 경우

     - Seven orphans 7 wait, 국사무쌍 7면(3점) : 쯔모나 론을 선언하기 전 갖고 있던 7개의 패가 모두 서로 다른 종류의 패일 경우 (단, 이미 자신이 버렸던 패와 같은 종류의 패로 쯔모를 선언할 경우 2점)

     - Seven orphans, 국사무쌍(1점) : 쯔모나 론을 선언하기 전 1종류의 또이쯔를 갖고 있었을 경우

  6. 특수한 방법으로 승리하는 경우 점수가 추가된다.

     - Heavenly hand, 천화(4점) : 먼저 시작하는 사람이 처음으로 받은 패로 쯔모 선언

     - Earthly hand, 지화(2점) : 나중에 시작하는 사람이 처음으로 받은 패로 쯔모 선언

     - Hand of man, 인화(2점) : 나중에 시작하는 사람이 먼저 시작하는 사람의 첫 버림패로 론 선언

     - Last draw, 해저로월(1점) : 마지막 남은 패를 받아와서 쯔모 선언

     - Last discard, 하저로어(1점) : 마지막으로 버려진 패를 론 선언

     - Dead wall draw, 영상개화(1점) : 깡 선언 직후 가져온 패로 쯔모 선언

     - Robbing a quad, 창깡(1점) : 상대방이 안깡한 패로 국사무쌍 형태를 완성시킬 수 있을 때 론 선언

## 3. 프로그램 상세 구성

### 3-1. mahjong.java

#### 3-1-1. 사용 변수

- round : 현재 진행 중인 라운드 번호를 저장한다.
- dealer : 먼저 시작하는 쪽과 패를 가져가는 쪽의 플레이어를 저장한다.
- GET : 현재 차례에 가져온 패, 또는 현재 차례에 버린 패를 저장한다.
- flag : 승패 또는 무승부가 확정되었는지 아닌지를 저장한다.
- flower : 영상패인지 아닌지를 저장한다.
- win : 승리한 쪽의 플레이어를 저장한다.
- scoremove : 어느 한 쪽이 승리한 경우, 그 점수를 저장한다.
- dealch : 대명깡/퐁을 해서 패산에서 패를 안 가져가고 차례가 바뀌는지를 저장한다.
- wantpon, wantkan, tsumocheck, roncheck : 각각 퐁/깡/쯔모/론 여부를 저장한다.
- ANK : 안깡을 할 경우 창깡 여부를 확인하기 위해 패의 종류를 저장한다.

#### 3-1-2. 프로그램 진행

- '게임 시작'을 선택한 경우

  - 시작하기 전 round와 dealer를 초기화하고, 게임을 개시하며 한 쪽의 점수가 0점 이하일 때까지 반복하고 메인 화면으로 돌아간다.

  - round 수를 1 늘리고, GET="", flag=false, flower=false, win=0, scoremove=0, dealch=0으로 각각 초기화한다.

  - 패를 섞은 뒤 CPU와 Player에게 패를 배분하고, dealer의 값을 먼저 시작하는 쪽으로 설정한다.

- 전체적인 게임 진행

  - 우선 모든 경우에서, 퐁/깡/쯔모/론을 할 수 있는 경우 플레이어 측은 할지 말지를 직접 입력받아 진행하며, CPU 측은 CPU_deck의 AI 메소드를 이용하여 할지 말지에 대한 여부를 판정하여 진행한다. 단, AI 설계 편의상 CPU측은 안깡/가깡은 무조건 하는 쪽으로 선택한다.

  - 패를 가져오는 모든 상황에서 더 이상 남아있는 패가 없다면 무승부로 처리되어 flag를 true로 바꾸고 루프를 탈출한다.

  - 그리고 어느 한 쪽 플레이어가 화료한다면 그 플레이어의 승리가 되어 dealer, win, scoremove 값을 승리한 쪽과 점수에 맞게 기록하고 flag를 true로 바꾼 뒤 루프를 탈출한다.
  - <u>플레이어 차례에서 문자 "Q"를 입력하면</u>, 자바 파일이 저장된 폴더에 mahjongStrore.txt라는 텍스트 파일을 생성하고, round, dealer, dealch, GET 변수와 CPU_deck, Player_deck, deck 자바 파일의 <u>정보를 자동으로 저장하고, 게임을 바로 종료한다.</u>

- 한 회전 안에서의 게임 진행

  - 첫 번째로, flower의 값을 false로 되돌리고 dealer의 값을 체크하여 어느 플레이어가 패를 가져갈 차례인지 확인한다.

  - 어느 한 쪽 플레이어가 패를 가져왔다면 먼저 안깡을 할 수 있는지 확인한다. 만약 안깡을 했다면, 상대 플레이어가 창깡을 할 수 있는지 확인하고, 패를 1개 더 가져온 뒤 영상개화 여부를 판단하기 위해 flower의 값을 true로 바꾼다.

  - 또한 안깡이 아닌 가깡을 할 수 있는 경우라면, 창깡 여부를 확인하지 않는다는 것을 제외하면 안깡과 동일하게 진행한다.

  - 패를 가져온 플레이어가 쯔모 화료할 수 있는지 확인한다.

  - 화료할 수 있는 경우가 아니라면 패를 가져온 플레이어는 필요 없는 패를 버린다. 플레이어 측에서 필요 없는 패의 문자를 입력하는 대신 문자 "Q"를 입력하면 파일의 정보를 자동으로 저장하고, 게임을 바로 종료한다.

  - 상대 플레이어는 이번 차례에 버려진 패로 론 화료할 수 있는지 확인한다.

  - 만약 론이 아닌 대명깡을 할 수 있는 경우에 대명깡을 한다면, 가깡을 했을 때처럼 패를 1개 더 가져오고 flower의 값을 1로 바꾸되 이때는 바로 영상개화 쯔모를 할 수 있는지 판단한 뒤 아니라면 필요 없는 패를 버리고 깡을 하지 않은 플레이어가 다음 차례에 패를 가져갈 수 있도록 dealch의 값을 1로 변경한다.

  - 그리고 퐁을 할 수 있는 경우에 퐁을 한다면, 바로 필요 없는 패를 버리고 역시 퐁을 하지 않은 플레이어가 패를 가져갈 수 있게 dealch의 값을 1로 변경한다.

  - 마지막으로 dealch의 값이 0인 경우라면, dealer의 값을 상대 플레이어의 차례에 맞게 변경한다.

  - 어느 한쪽이 승리하거나 무승부가 되어 루프를 빠져나왔다면, win과 scoremove의 값에 맞게 양쪽 플레이어의 점수를 변경하고 현재 점수 상태를 출력한 뒤 어느 한 쪽 플레이어가 0점 이하가 되기 전까지 이 루프를 반복한다.

- '불러오기'를 선택한 경우
  - 생성된 mahjongStrore.txt 파일에 기록된 내용을 불러오고, 처음 게임을 시작할 때 각종 변수를 초기화하는 대신 파일에 기록된 내용을 토대로 변수의 값들을 지정해준다. 이후의 진행은게임 시작을 선택했을 때와 같다.
- '규칙'을 선택한 경우
  - 자패마작의 규칙을 텍스트로 출력한다.
- '나가기'를 선택한 경우
  - 프로그램을 종료한다.

### 3-2. rulebook.java

#### 3-2-1. 사용 변수

- rule : 메인 화면에서 규칙을 선택했을 경우, 자패마작의 규칙을 텍스트로 출력한다.

### 3-3. invalidcards.java

#### 3-3-1. 사용 기능

- toString : 사용자가 버릴 패의 문자를 잘못 입력한 경우, 버릴 수 없는 카드라는 문구를 반환한다.

### 3-4. runoutcards.java

#### 3-4-1. 사용 기능

- toString : 모든 패를 사용하여 더 이상 패를 가져올 수 없는 경우, 패가 다 떨어졌다는 문구를 반환한다.

### 3-5. deck.java

#### 3-5-1. 사용 변수

- cards : 덱에 들어 있는 28개의 패를 저장한다.

- ranks : 패 종류별로 이름을 저장한다.
  - 東="E", 南="S", 西="W", 北="N", 白="O", 發="G", 中=“R"

- num : 덱에서 현재 가져갈 패 차례 번호를 저장한다.

#### 3-5-2. 사용 기능

+ deck : 처음 클래스를 선언할 때 cards 배열에 주소 그대로의 번호를 기록한다.

+ shuffle : num을 초기화하고 28장의 패를 섞은 뒤, cards 배열에 패의 번호를 기록한다.

+ getcards : 패를 가져올 때 num의 숫자를 1 더한 뒤 cards 배열의 num에 해당하는 패 번호를 반환한다. 만약 num이 cards 배열을 참조하지 못하는 경우 Runoutcards 예외를 반환한다.

+ numinfo : 현재 num의 값을 토대로 남아있는 패의 개수를 반환한다.

### 3-6. Player_deck.java

#### 3-6-1. 사용 변수

- furiten : 해당하는 종류의 패를 이미 버린 적이 있는 지를 저장한다.

- number : 패의 종류별로 가지고 있는 개수대로 저장한다.

  - 0~4 : 0~4개, 5 : 퐁, 6 : 퐁+1개, 7 : 대명깡, 8 : 안깡, 9 : 가깡

- ranks : 패 종류별로 이름을 저장한다. deck.java의 같은 이름의 변수와 동일하다.

- thrown_cards : 현재까지 버린 패의 목록을 문자열로 저장한다.

- score : 현재 점수를 저장한다.

- ANTRIP, KAN, DRAG, WIND, ORDI, TOITU, GOKUSI : 패의 상세한 정보를 저장한다.

  - ANTRIP : 안커의 개수

  - KAN : 깡쯔의 종류와 개수 – 안깡은 2, 다른 깡은 1로 계산하여 모두 더한 값

  - DRAG : 白發中 패의 커쯔/깡쯔 또는 또이쯔의 총합 – 커쯔/깡쯔는 2, 또이쯔는 1로 계산

  - WIND : 東南西北 패의 커쯔/깡쯔 또는 또이쯔의 총합 – 위 DRAG 변수와 동일하게 계산

  - ORDI : 패의 구성이 몸통 2개 + 머리 1개인지의 여부

  - TOITU : 패의 구성이 머리 4개인지의 여부

  - GOKUSI : 패의 구성이 국사무쌍 형태인지의 여부 – 일반 1, 7면 후리텐 쯔모 2, 7면 3

#### 3-6-2. 사용 기능

+ reset : ANTRIP~GOKUSI 변수와 furiten, number 배열, thrown_cards 변수를 초기화한다.

+ scoreset : score 변수를 초기값 15로 되돌린다.

+ scoreget : score 변수의 값을 반환한다.

+ scorechange : score 변수를 입력받은 점수만큼 더한다.

+ scorestore : score 변수를 입력받은 점수로 치환한다.

+ pick : 이번 차례에 가져온 패를 입력받아 number 변수에 기록한다.

+ called : 퐁이나 대명깡을 당했을 경우, thrown_cards 변수 끝에 "!"를 추가한다.

+ discard : 이번 차례에 버릴 패를 입력받아 number와 thrown_cards 변수에 기록한다. 만약 버릴 수 없는 패일 경우 Invalidcards 예외를 실행한다.

+ lastthrow : 마지막으로 버린 패를 thrown_cards 변수에서 char 형태로 떼어내 반환한다.

+ throwns : 현재까지 버린 패의 목록을 thrown_cards 변수를 이용해 반환한다.

+ getinfo : 현재 패의 상태를 String 형태로 만들어 반환한다.

  - tsumo가 true일 경우, 패의 상태를 계산하기 전 number 변수에 code 변수에 해당하는 패를 임시로 추가한다.

  - Ordinary 변수에는 퐁과 깡을 하지 않은 손패 그대로를 기록하고, Pons 변수에는 퐁한 패를 XX+X 형태로 기록, Kans 변수에는 안깡한 패는 XXXX, 대명깡한 패는 XXX+X, 가깡한 패는 XX+X+X 형태로 기록한다.

  - 마지막으로 Info 변수에 퐁이나 깡한 패가 없을 경우에는 Ordinary 변수만 복사하고, 있을 경우에는 해당하는 변수를 뒤에 덧붙여 반환한다.

+ wincheck : 현재 패의 상태가 화료할 수 있는 상태인지를 반환한다.
  + 이하의 변수들에 값을 각각 기록하여 화료할 수 있는 점수가 있는지 판단한다. 만약 화료할 수 있는 상태라면 클래스 변수 ANTRIP~GOKUSI에 해당하는 값을 기록해 둔다.
  + pair 변수 - 또이쯔 개수
  + trip 변수 - 커쯔/깡쯔 개수
  + antrip 변수 - 안커 개수
  + inkans 변수 - 안깡 개수
  + outkans 변수 - 가깡/대명깡 개수
  + winds 변수 - 풍패 또이쯔/커쯔/깡쯔 개수
  + dragons 변수 - 삼원패 또이쯔/커쯔/깡쯔 개수

+ scoreprint : wincheck 메소드에서 기록한 클래스 변수 ANTRIP~GOKUSI와 입력받은 변수 num, tsumo, flower, chang의 값을 토대로 scoreprint의 calculator 메소드를 호출하여 값을 받아 반환한다.

+ poncheck : 현재 퐁을 할 수 있는 지의 여부를 반환한다.

+ kancheck : 현재 대명깡을 할 수 있는 지의 여부를 반환한다.

+ sidekancheck : 현재 가깡을 할 수 있는 지의 여부를 반환한다.

+ ankancheck : 현재 안깡을 할 수 있는 지의 여부를 반환한다.

+ pon : number 변수에 입력받은 패를 퐁으로 기록한다.

+ kan : number 변수에 입력받은 패를 깡으로 기록한다.

### 3-7. CPU_deck.java

#### 3-7-1. 사용 기능

- 편의를 위해 Player_deck.java와 다른 기능만 서술한다.

- getinfo : readable이 false인 경우 손패를 기록할 때 패의 개수만큼 "?"를 기록하며, true인 경우는 Player_deck의 getinfo 메소드와 같다.

- AI : 각각의 상황에서 어떤 판단을 내릴지에 대해 반환한다.

  - wincheck 메소드에 추가로 onewind는 1개짜리 풍패 개수, onedragon은 1개짜리 풍패 개수, codenow는 입력받은 패의 종류를 기록하여 상황에 맞게 다음과 같이 판단한다.

  - 대명깡인 경우 : 이미 가깡/안깡을 1번 했을 경우에만 한다.

  - 퐁의 경우 : 안커가 하나 있거나, 풍패나 삼원패 또이쯔를 어느 쪽이건 2종류 이상 가지고 있거나, 한 종류를 퐁을 했고 같은 종류의 풍패/삼원패를 또이쯔로 들고 있어 그 패를 퐁 할 수 있는 경우에는 퐁을 한다.

  - 패를 버리는 경우

    - 다음과 같은 규칙에 따라 판단을 한 뒤 noneed 변수에 버릴 패의 종류를 기록하여 반환한다.
    - 모든 경우에서 가깡을 하지 않는 경우, 가깡 하지 않은 패를 우선적으로 버린다.

    - 패가 6종류이고 퐁을 하지 않은 경우, 또이쯔나 커쯔인 패 중 이미 후리텐인 패를 버린다. 해당하는 패가 모두 후리텐일 경우 삼원패 쪽을 먼저 버린다.

    - 패가 6종류이면서 퐁을 했거나 패가 5종류인 경우, 또는 패가 4종류이면서 커쯔가 2개 이상일 경우, 풍패나 삼원패 쪽으로 패가 몰려 있는 경우에는 1개만 남은 패 중 서로 다른 종류의 패를 먼저 버린다. 그렇지 않을 경우에는 1개만 남은 패 중 이미 후리텐인 패를 버리며, 해당하는 패가 모두 후리텐일 경우 삼원패 쪽을 먼저 버린다.

    - 그 외의 경우, 1개만 남은 패 중 이미 후리텐인 패를 버린다. 해당하는 패가 모두 후리텐일 경우 삼원패 쪽을 먼저 버린다.

### 3-8. gameprint.java

#### 3-8-1. 사용 기능

+ mainprint : 플레이어의 차례가 될 때마다 양 플레이어의 패와 점수, 남은 패의 개수를 출력한다. CPU가 퐁, 깡을 하지 않은 패는 볼 수 없다.

+ vspoint : 양 플레이어의 점수를 출력하며, 출력하고 난 뒤에는 5초 동안 딜레이 후 어느 한쪽 플레이어의 점수가 0점 이하인지의 여부를 반환한다.

+ cardthrow_p : 플레이어가 버릴 패의 문자열을 입력받아 그 패를 버린다. 만약 Q를 입력받을 경우 게임을 자동 저장하고 종료한다. 만약 버릴 수 없는 패를 입력하거나 잘못된 문자를 입력했을 경우 입력을 다시 받는다.

+ cardthrow_c : CPU가 버릴 패를 CPU_deck의 AI 메소드로 입력받아 버린다.

+ tsumoprint_p : 플레이어가 쯔모 화료했을 경우, 상세 점수를 출력하고 그 점수를 반환한다.

+ ronprint_p : 플레이어가 론 화료했을 경우, 상세 점수를 출력하고 그 점수를 반환한다.

+ tsumoprint_c : CPU가 쯔모 화료했을 경우, 상세 점수를 출력하고 그 점수를 반환한다.

+ ronprint_c : CPU가 론 화료했을 경우, 상세 점수를 출력하고 그 점수를 반환한다.

### 3-9. scoreprint.java

#### 3-9-1. 사용 기능

- calculator : 패의 상세 정보를 입력받아 점수를 계산해서 반환한다.

  - ANTRIP~GOKUSI : Player_deck의 변수와 동일

  - NUM : 현재 남은 패의 개수로 천화, 지화, 인화, 해저로월, 하저로어에 사용

  - TSUMO : 쯔모화료 여부, FLOWER : 영상개화 여부, CHANG : 창깡 여부

 ## 4. 제작 후기

- 프로그램을 직접 작성하다보니 계획했던 것들과 실제로 구현했을 때의 괴리감이 커서 아쉬웠다. 또한 시간에 쫓겨 프로그램을 작성하다 보니 곳곳에 부족한 점이 많이 보였다. 그래도 여러 명이서 함께 프로그램을 짜다보니 혼자서 프로그램을 짤 때 부족했던 부분들을 쉽게 보완할 수 있어서 좋았었던 것 같다.